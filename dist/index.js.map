{"version":3,"file":"index.js","sources":["../src/lru.js","../src/index.js"],"sourcesContent":["const NEWER = Symbol('N')\nconst OLDER = Symbol('O')\n\n/**\n * https://github.com/stereobooster/lru_map/blob/stereobooster/index.js\n *\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\nexport default class LRUMap {\n  constructor (limit, entries) {\n    this.size = 0\n    this.limit = limit\n    this.oldest = this.newest = undefined\n    this.map = new Map()\n\n    if (entries) {\n      this.assign(entries)\n      if (limit < 1) {\n        this.limit = this.size\n      }\n    }\n  }\n\n  _bump (entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER]\n      }\n      entry[NEWER][OLDER] = entry[OLDER] // C <-- E.\n    }\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER] // C. --> E\n    }\n    entry[NEWER] = undefined // D --x\n    entry[OLDER] = this.newest // D. --> E\n    if (this.newest) {\n      this.newest[NEWER] = entry // E. <-- D\n    }\n    this.newest = entry\n  }\n\n  get (key) {\n    // First, find our cache entry\n    let entry = this.map.get(key)\n    if (!entry) return // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    this._bump(entry)\n    return entry.value\n  }\n\n  set (key, value) {\n    let entry = this.map.get(key)\n\n    if (entry) {\n      // update existing\n      entry.value = value\n      this._bump(entry)\n      return this\n    }\n\n    // new entry\n    this.map.set(key, (entry = { key, value }))\n\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry\n      entry[OLDER] = this.newest\n    } else {\n      // we're first in -- yay\n      this.oldest = entry\n    }\n\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.newest = entry\n    ++this.size\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift()\n    }\n\n    return this\n  }\n\n  shift () {\n    // todo: handle special case when limit == 1\n    let entry = this.oldest\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER]\n        this.oldest[OLDER] = undefined\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined\n        this.newest = undefined\n      }\n      // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n      entry[NEWER] = entry[OLDER] = undefined\n      this.map.delete(entry.key)\n      --this.size\n      return [entry.key, entry.value]\n    }\n  }\n\n  has (key) {\n    return this.map.has(key)\n  }\n\n  assign (entries) {\n    let entry\n    let limit = this.limit || Number.MAX_VALUE\n    this.map.clear()\n    let it = entries[Symbol.iterator]()\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = { key: itv.value[0], value: itv.value[1] }\n      this.map.set(e.key, e)\n      if (!entry) {\n        this.oldest = e\n      } else {\n        entry[NEWER] = e\n        e[OLDER] = entry\n      }\n      entry = e\n      if (limit-- === 0) {\n        throw new Error('overflow')\n      }\n    }\n    this.newest = entry\n    this.size = this.map.size\n  }\n\n  clear () {\n    // Not clearing links should be safe, as we don't expose live links to user\n    this.oldest = this.newest = undefined\n    this.size = 0\n    this.map.clear()\n  }\n}\n","import React, { useState, useEffect } from 'react'\nimport PropTypes from 'prop-types'\nimport XXH from 'xxhashjs'\nimport LRUMap from './lru'\n\nconst HASH_SEED = 121212\nconst LRU_LIMIT = 100\n\nfunction getKey () {\n  return XXH.h32(JSON.stringify(arguments), HASH_SEED).toString(16)\n}\n\n/**\n * @name Provider\n *\n * @description\n *  Each Provider have your own cache object, what means that you\n *  could have same resource name for differents cahce providers\n *\n * @example\n * <Provider context={userContext} fetchList={fetchUserList} fetchItem={fetchUserItem}>\n *  ...\n * </Provider>\n */\nexport default function Provider ({\n  children,\n  context,\n  initialItems = null,\n  limit = LRU_LIMIT,\n  externalResources = {},\n  ...props\n}) {\n  const [lru] = useState(() => {\n    return new LRUMap(limit)\n  })\n\n  /**\n   * Crear LRU cache, don't affect state, only clear the lru cache\n   */\n  function clearCache () {\n    lru.clear()\n  }\n\n  /**\n   * Return the resrouce function\n   *\n   * @param {String} name - resource name\n   * @param {*} force - skip check if exist cache when resource run\n   */\n  function getResource (name, force = false) {\n    return function () {\n      const args = arguments\n      const key = getKey(name, args)\n      const recoveryResource = lru.get(key)\n      if (force || recoveryResource === undefined) {\n        const resource = props[name] || externalResources[name]\n        if (typeof resource === 'undefined') {\n          throw Error(`Context:Cache:Provider ${name} resource is undefined`)\n        }\n\n        const deffered = new Promise(function (resolve) {\n          const promiseResource = {\n            status: 'pending',\n            args: undefined\n          }\n          lru.set(key, promiseResource)\n\n          const resultResource = resource.apply(null, args)\n          if (typeof resultResource.then === 'function') {\n            return resultResource.then(function () {\n              resolve.apply(null, arguments)\n            })\n          }\n          resolve(resultResource)\n        })\n\n        deffered.then(function (result) {\n          // first argument as resolved promise experct\n          const newPromiseResource = {\n            status: 'resolved',\n            args: result\n          }\n          lru.set(key, newPromiseResource)\n        })\n\n        throw deffered\n      }\n\n      if (recoveryResource.status === 'resolved') {\n        // if (typeof recoveryResource.args === 'object') {\n        //   return Object.values(recoveryResource.args)\n        // }\n        return recoveryResource.args\n      }\n    }\n  }\n\n  function hit (name, ...args) {\n    const key = getKey(name, Object.assign({}, args))\n    return lru.has(key)\n  }\n\n  return (\n    <context.Provider value={{ getResource, clearCache, hit }}>\n      {children}\n    </context.Provider>\n  )\n}\n\nProvider.propTypes = {\n  children: PropTypes.any.isRequired,\n  context: PropTypes.object.isRequired,\n  initialItems: PropTypes.any,\n  limit: PropTypes.number,\n  externalResources: PropTypes.object\n}\n"],"names":["NEWER","Symbol","OLDER","LRUMap","limit","entries","size","oldest","newest","undefined","map","Map","assign","entry","key","get","_bump","value","set","shift","delete","has","Number","MAX_VALUE","clear","it","iterator","itv","next","done","e","Error","HASH_SEED","LRU_LIMIT","getKey","XXH","h32","JSON","stringify","arguments","toString","Provider","children","context","initialItems","externalResources","props","useState","lru","clearCache","getResource","name","force","args","recoveryResource","resource","deffered","Promise","resolve","promiseResource","resultResource","apply","then","result","newPromiseResource","status","hit","Object","React","propTypes","PropTypes","any","isRequired","object","number"],"mappings":"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"}