{"version":3,"file":"index.js","sources":["../src/lru.js","../src/index.js"],"sourcesContent":["const NEWER = Symbol('N')\nconst OLDER = Symbol('O')\n\n/**\n * https://github.com/stereobooster/lru_map/blob/stereobooster/index.js\n *\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\nexport default class LRUMap {\n  constructor (limit, entries) {\n    this.size = 0\n    this.limit = limit\n    this.oldest = this.newest = undefined\n    this.map = new Map()\n\n    if (entries) {\n      this.assign(entries)\n      if (limit < 1) {\n        this.limit = this.size\n      }\n    }\n  }\n\n  _bump (entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER]\n      }\n      entry[NEWER][OLDER] = entry[OLDER] // C <-- E.\n    }\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER] // C. --> E\n    }\n    entry[NEWER] = undefined // D --x\n    entry[OLDER] = this.newest // D. --> E\n    if (this.newest) {\n      this.newest[NEWER] = entry // E. <-- D\n    }\n    this.newest = entry\n  }\n\n  get (key) {\n    // First, find our cache entry\n    let entry = this.map.get(key)\n    if (!entry) return // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    this._bump(entry)\n    return entry.value\n  }\n\n  set (key, value) {\n    let entry = this.map.get(key)\n\n    if (entry) {\n      // update existing\n      entry.value = value\n      this._bump(entry)\n      return this\n    }\n\n    // new entry\n    this.map.set(key, (entry = { key, value }))\n\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry\n      entry[OLDER] = this.newest\n    } else {\n      // we're first in -- yay\n      this.oldest = entry\n    }\n\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.newest = entry\n    ++this.size\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift()\n    }\n\n    return this\n  }\n\n  shift () {\n    // todo: handle special case when limit == 1\n    let entry = this.oldest\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER]\n        this.oldest[OLDER] = undefined\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined\n        this.newest = undefined\n      }\n      // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n      entry[NEWER] = entry[OLDER] = undefined\n      this.map.delete(entry.key)\n      --this.size\n      return [entry.key, entry.value]\n    }\n  }\n\n  has (key) {\n    return this.map.has(key)\n  }\n\n  assign (entries) {\n    let entry\n    let limit = this.limit || Number.MAX_VALUE\n    this.map.clear()\n    let it = entries[Symbol.iterator]()\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = { key: itv.value[0], value: itv.value[1] }\n      this.map.set(e.key, e)\n      if (!entry) {\n        this.oldest = e\n      } else {\n        entry[NEWER] = e\n        e[OLDER] = entry\n      }\n      entry = e\n      if (limit-- === 0) {\n        throw new Error('overflow')\n      }\n    }\n    this.newest = entry\n    this.size = this.map.size\n  }\n\n  clear () {\n    // Not clearing links should be safe, as we don't expose live links to user\n    this.oldest = this.newest = undefined\n    this.size = 0\n    this.map.clear()\n  }\n}\n","import React, { useState, useEffect } from 'react'\nimport PropTypes from 'prop-types'\nimport XXH from 'xxhashjs'\nimport LRUMap from './lru'\n\nconst HASH_SEED = 121212\nconst LRU_LIMIT = 100\n\nfunction getKey (name, args) {\n  return XXH.h32(JSON.stringify(arguments), HASH_SEED).toString(16)\n}\n\n/**\n * @name Provider\n *\n * @description\n *  Each Provider have your own cache object, what means that you\n *  could have same resource name for differents cahce providers\n *\n * @example\n * <Provider context={userContext} fetchList={fetchUserList} fetchItem={fetchUserItem}>\n *  ...\n * </Provider>\n */\nexport default function Provider ({\n  children,\n  context,\n  initialItems = null,\n  limit = LRU_LIMIT,\n  externalResources = {},\n  ...props\n}) {\n  const setTick = useState(void 0)[1]\n  const [lru] = useState(() => {\n    return new LRUMap(limit)\n  })\n\n  /**\n   * Crear LRU cache, don't affect state, only clear the lru cache\n   */\n  function clearCache () {\n    lru.clear()\n  }\n\n  /**\n   * Return the resrouce function\n   *\n   * @param {String} name - resource name\n   * @param {*} force - skip check if exist cache when resource run\n   */\n  function getResource (name, force = false) {\n    return function () {\n      const args = arguments\n      const key = getKey(name, args)\n      if (force || !lru.has(key)) {\n        const resource = props[name] || externalResources[name]\n        if (typeof resource === 'undefined') {\n          throw Error(`Context:Cache:Provider ${name} resource is undefined`)\n        }\n        if (typeof resource.then === 'function') {\n          const deffered = new Promise(function (resolve, reject) {\n            return resource.apply(null, args).then(function () {\n              resolve.apply(null, arguments)\n            })\n          }).then(function () {\n            // first argument as resolved promise experct\n            const newPromiseResource = {\n              type: 'promise',\n              status: 'resolved',\n              args: arguments[0]\n            }\n            lru.set(key, newPromiseResource)\n            setTick(void 0)\n          })\n          const promiseResource = {\n            type: 'promise',\n            status: 'pending',\n            args: undefined\n          }\n          lru.set(key, promiseResource)\n          setTick(void 0)\n          throw deffered\n        }\n\n        if (typeof resource === 'function') {\n          const response = resource.apply(null, args)\n          const promiseResource = {\n            type: 'function',\n            status: 'resolved',\n            args: response\n          }\n          lru.set(key, promiseResource)\n          setTick(void 0)\n          return undefined\n        }\n\n        return resource\n      }\n      const recoveryResource = lru.get(key)\n      if (recoveryResource.status === 'resolved') {\n        if (typeof recoveryResource.args === 'object') {\n          return Object.values(recoveryResource.args)\n        }\n        return recoveryResource.args\n      }\n    }\n  }\n\n  function hit (name, ...args) {\n    const key = getKey(name, args)\n    return lru.has(key)\n  }\n\n  return (\n    <context.Provider value={{ getResource, clearCache, hit }}>\n      {children}\n    </context.Provider>\n  )\n}\n\nProvider.propTypes = {\n  children: PropTypes.any.isRequired,\n  context: PropTypes.object.isRequired,\n  initialItems: PropTypes.any,\n  limit: PropTypes.number,\n  externalResources: PropTypes.object\n}\n"],"names":["NEWER","Symbol","OLDER","LRUMap","limit","entries","size","oldest","newest","undefined","map","Map","assign","entry","key","get","_bump","value","set","shift","delete","has","Number","MAX_VALUE","clear","it","iterator","itv","next","done","e","Error","HASH_SEED","LRU_LIMIT","getKey","name","args","XXH","h32","JSON","stringify","arguments","toString","Provider","children","context","initialItems","externalResources","props","setTick","useState","lru","clearCache","getResource","force","resource","then","deffered","Promise","resolve","reject","apply","newPromiseResource","promiseResource","response","recoveryResource","status","babelHelpers.typeof","Object","values","hit","React","propTypes","PropTypes","any","isRequired","object","number"],"mappings":"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"}