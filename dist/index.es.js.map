{"version":3,"file":"index.es.js","sources":["../src/lru.js","../src/index.js"],"sourcesContent":["const NEWER = Symbol(\"N\");\nconst OLDER = Symbol(\"O\");\n\n/**\n * https://github.com/stereobooster/lru_map/blob/stereobooster/index.js\n *\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\nexport default class LRUMap {\n  constructor(limit , entries) {\n    this.size = 0;\n    this.limit = limit;\n    this.oldest = this.newest = undefined;\n    this.map = new Map();\n\n    if (entries) {\n      this.assign(entries);\n      if (limit < 1) {\n        this.limit = this.size;\n      }\n    }\n  }\n\n  _bump(entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER];\n      }\n      entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n    }\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n    }\n    entry[NEWER] = undefined; // D --x\n    entry[OLDER] = this.newest; // D. --> E\n    if (this.newest) {\n      this.newest[NEWER] = entry; // E. <-- D\n    }\n    this.newest = entry;\n  }\n\n  get(key) {\n    // First, find our cache entry\n    let entry = this.map.get(key);\n    if (!entry) return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    this._bump(entry);\n    return entry.value;\n  }\n\n  set(key, value) {\n    let entry = this.map.get(key);\n\n    if (entry) {\n      // update existing\n      entry.value = value;\n      this._bump(entry);\n      return this;\n    }\n\n    // new entry\n    this.map.set(key, (entry = { key, value }));\n\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry;\n      entry[OLDER] = this.newest;\n    } else {\n      // we're first in -- yay\n      this.oldest = entry;\n    }\n\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.newest = entry;\n    ++this.size;\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift();\n    }\n\n    return this;\n  }\n\n  shift() {\n    // todo: handle special case when limit == 1\n    let entry = this.oldest;\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER];\n        this.oldest[OLDER] = undefined;\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined;\n        this.newest = undefined;\n      }\n      // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n      entry[NEWER] = entry[OLDER] = undefined;\n      this.map.delete(entry.key);\n      --this.size;\n      return [entry.key, entry.value];\n    }\n  }\n\n  has(key) {\n    return this.map.has(key);\n  };\n\n  assign(entries) {\n    let entry,\n      limit = this.limit || Number.MAX_VALUE;\n    this.map.clear();\n    let it = entries[Symbol.iterator]();\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = { key: itv.value[0], value: itv.value[1] };\n      this.map.set(e.key, e);\n      if (!entry) {\n        this.oldest = e;\n      } else {\n        entry[NEWER] = e;\n        e[OLDER] = entry;\n      }\n      entry = e;\n      if (limit-- === 0) {\n        throw new Error(\"overflow\");\n      }\n    }\n    this.newest = entry;\n    this.size = this.map.size;\n  };\n\n  clear() {\n    // Not clearing links should be safe, as we don't expose live links to user\n    this.oldest = this.newest = undefined;\n    this.size = 0;\n    this.map.clear();\n  };\n}\n","import React, { useState, useEffect } from \"react\";\nimport LRUMap from \"./lru\";\nimport XXH from \"xxhashjs\";\n\nconst hashSeed = \"notsecurity\";\nconst lru = new LRUMap(100);\n\nfunction getKey(name, args) {\n  return XXH.h32(JSON.stringify(arguments), hashSeed).toString(16);\n}\n\nexport default function Provider({\n                                   children,\n                                   context,\n                                   initialItems = null,\n                                   externalResources = {},\n                                   ...props\n                                 }) {\n  const setTick = useState(void 0)[1];\n\n  useEffect(() => initialItems && lru.assign(initialItems));\n  function clearCache() {\n    lru.clear();\n  }\n  function getResource(name, force = false) {\n    return function() {\n      const args = arguments;\n      const key = getKey(name, args);\n\n      if (force || !lru.has(key)) {\n        const resource = props[name] || externalResources[name];\n        const promise = new Promise(function(resolve, reject) {\n          resource.apply(null, args).then(function() {\n            resolve.apply(null, arguments);\n          });\n        });\n\n        var promiseResource = {\n          status: \"pending\",\n          // promise,\n          args: undefined\n        };\n\n        promise.then(function() {\n          const newData = { status: \"resolved\", args: arguments };\n          lru.set(key, newData);\n          setTick(void 0);\n        });\n\n        lru.set(key, promiseResource);\n        setTick(void 0);\n        // throw promiseResource.promise;\n        throw promise;\n      }\n\n      const recoveryResource = lru.get(key);\n      if (recoveryResource.status === \"resolved\") {\n        return recoveryResource.args[0];\n      }\n    };\n  }\n\n  return (\n    <context.Provider value={{ getResource, clearCache }}>\n      {children}\n    </context.Provider>\n  );\n}\n"],"names":["NEWER","Symbol","OLDER","LRUMap","limit","entries","size","oldest","newest","undefined","map","Map","assign","entry","key","get","_bump","value","set","shift","delete","has","Number","MAX_VALUE","clear","it","iterator","itv","next","done","e","Error","hashSeed","lru","getKey","name","args","XXH","h32","JSON","stringify","arguments","toString","Provider","children","context","initialItems","externalResources","props","setTick","useState","clearCache","getResource","force","resource","promise","Promise","resolve","reject","apply","then","promiseResource","newData","status","recoveryResource"],"mappings":"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"}